from .nodes import Node, count_nodes
from .smtlib import *
from . import options


class Constants:
    """Replaces any node by a constant."""
    def filter(self, node):
        return get_sort(node) is not None

    def mutations(self, node):
        """Return :code:`get_constants(get_sort(node))`."""
        t = get_sort(node)
        if t is None:
            return []
        res = get_constants(t)
        if node in res:
            return []
        return res

    def __str__(self):
        return 'substitute by a constant'


class EraseNode:
    """Erase nodes optionally with a specified identifier :code:`ident`."""
    def filter(self, node):
        if not hasattr(self, 'ident'):
            return True
        return has_ident(node) and get_ident(node) == self.ident

    """Erases the given node."""

    def mutations(self, node):
        return [None]

    def __str__(self):
        if hasattr(self, 'ident'):
            return f'erase node ({self.ident})'
        return 'erase node'


class MergeWithChildren:
    """Merges a node with one of its children.

    This is possible for n-ary operators like :code:`and` or :code:`+`.
    """
    def filter(self, node):
        return has_nary_operator(node)

    def mutations(self, node):
        for cid, child in enumerate(node):
            if has_ident(child) and get_ident(node) == get_ident(child):
                yield Node(*node[:cid], *node[cid][1:], *node[cid + 1:])

    def __str__(self):
        return 'merge with child'


class ReplaceByChild:
    """Replace a node by one of its children."""
    def filter(self, node):
        return not is_leaf(node) and not is_operator_app(node, 'let')

    def mutations(self, node):
        yield from node[1:]

    def __str__(self):
        return 'replace by a child'


class ReplaceByVariable:
    """Replaces a node by a variable."""
    def filter(self, node):
        return not is_const(node)

    def mutations(self, node):
        if not hasattr(self, 'repl_mode'):
            self.repl_mode = options.args().replace_by_variable_mode

        ret_sort = get_sort(node)
        if ret_sort is None:
            return []
        variables = get_variables_with_sort(ret_sort)
        if is_leaf(node):
            if self.repl_mode == 'inc':
                return [Node(v) for v in variables if len(v) > len(node.data)]
            return [Node(v) for v in variables if len(v) < len(node.data)]
        return [Node(v) for v in variables]

    def __str__(self):
        if hasattr(self, 'repl_mode'):
            return f'substitute by existing variable ({self.repl_mode})'
        return 'substitute by existing variable'


class SortChildren:
    """Sorts the children of a node."""
    def filter(self, node):
        return not is_leaf(node)

    def mutations(self, node):
        """Return :code:`sorted(node, key = count_nodes)`."""
        s = nodes.Node(*sorted(node, key=count_nodes))
        if s != node:
            return [s]
        return []

    def __str__(self):
        return 'sort children'


class TopLevelBinaryReduction:
    """Performs binary reduction on the top level node.

    Essentially mimics line based reduction.
    """
    def global_mutations(self, linput, ginput):
        if linput != ginput[0]:
            return []
        # generate all sublists as generated by binary-search in bfs order
        # let den be the denominator of the list length (the tree level)
        # let num be the numerator within the current tree level
        # to avoid checking to many cases, we skip every second level (den *= 4)
        # and already stop when den*8 >= length.
        if hasattr(self, 'ident'):
            ids = [
                node.id for node in ginput
                if is_operator_app(node, self.ident)
            ]
        else:
            ids = [node.id for node in ginput]
        den = 2
        while den * 2 < len(ids):
            for num in reversed(range(0, den)):
                start = int(num / den * len(ids))
                end = int((num + 1) / den * len(ids))
                yield {nodeid: None for nodeid in ids[start:end]}
            den *= 2

    def __str__(self):
        if hasattr(self, 'ident'):
            return f'binary reduction ({self.ident})'
        return 'binary reduction'


def get_mutator_options(argparser):
    """Add additional options to the argument parser."""
    argparser.add_argument(
        '--replace-by-variable-mode',
        choices=['inc', 'dec'],
        default='inc',
        help='replace with existing variables that are larger or smaller')


def get_mutators():
    """Returns a mapping from mutator class names to the name of their config
    options."""
    return {
        'Constants': 'constants',
        'EraseNode': 'erase-node',
        'MergeWithChildren': 'merge-children',
        'ReplaceByChild': 'substitute-children',
        'ReplaceByVariable': 'replace-by-variable',
        'SortChildren': 'sort-children',
        'TopLevelBinaryReduction': 'top-level-binary-reduction',
    }
